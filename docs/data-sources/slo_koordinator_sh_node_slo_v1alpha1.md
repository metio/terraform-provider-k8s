---
# generated by https://github.com/hashicorp/terraform-plugin-docs
page_title: "k8s_slo_koordinator_sh_node_slo_v1alpha1 Data Source - terraform-provider-k8s"
subcategory: "slo.koordinator.sh"
description: |-
  NodeSLO is the Schema for the nodeslos API
---

# k8s_slo_koordinator_sh_node_slo_v1alpha1 (Data Source)

NodeSLO is the Schema for the nodeslos API

## Example Usage

```terraform
data "k8s_slo_koordinator_sh_node_slo_v1alpha1" "example" {
  metadata = {
    name = "some-name"

  }
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `metadata` (Attributes) Data that helps uniquely identify this object. See https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata for more details. (see [below for nested schema](#nestedatt--metadata))

### Read-Only

- `api_version` (String) The API group of the requested resource.
- `id` (String) Contains the value `metadata.name`.
- `kind` (String) The type of the requested resource.
- `spec` (Attributes) NodeSLOSpec defines the desired state of NodeSLO (see [below for nested schema](#nestedatt--spec))

<a id="nestedatt--metadata"></a>
### Nested Schema for `metadata`

Required:

- `name` (String) Unique identifier for this object. See https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names for more details.

Read-Only:

- `annotations` (Map of String) Keys and values that can be used by external tooling to store and retrieve arbitrary metadata about this object. See https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/ for more details.
- `labels` (Map of String) Keys and values that can be used to organize and categorize objects. See https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/ for more details.


<a id="nestedatt--spec"></a>
### Nested Schema for `spec`

Read-Only:

- `cpu_burst_strategy` (Attributes) CPU Burst Strategy (see [below for nested schema](#nestedatt--spec--cpu_burst_strategy))
- `extensions` (Map of String) Third party extensions for NodeSLO
- `host_applications` (Attributes List) QoS management for out-of-band applications (see [below for nested schema](#nestedatt--spec--host_applications))
- `resource_qos_strategy` (Attributes) QoS config strategy for pods of different qos-class (see [below for nested schema](#nestedatt--spec--resource_qos_strategy))
- `resource_used_threshold_with_be` (Attributes) BE pods will be limited if node resource usage overload (see [below for nested schema](#nestedatt--spec--resource_used_threshold_with_be))
- `system_strategy` (Attributes) node global system config (see [below for nested schema](#nestedatt--spec--system_strategy))

<a id="nestedatt--spec--cpu_burst_strategy"></a>
### Nested Schema for `spec.cpu_burst_strategy`

Read-Only:

- `cfs_quota_burst_percent` (Number) pod cfs quota scale up ceil percentage, default = 300 (300%)
- `cfs_quota_burst_period_seconds` (Number) specifies a period of time for pod can use at burst, default = -1 (unlimited)
- `cpu_burst_percent` (Number) cpu burst percentage for setting cpu.cfs_burst_us, legal range: [0, 10000], default as 1000 (1000%)
- `policy` (String)
- `share_pool_threshold_percent` (Number) scale down cfs quota if node cpu overload, default = 50


<a id="nestedatt--spec--host_applications"></a>
### Nested Schema for `spec.host_applications`

Read-Only:

- `cgroup_path` (Attributes) Optional, defines the host cgroup configuration, use default if not specified according to priority and qos (see [below for nested schema](#nestedatt--spec--host_applications--cgroup_path))
- `name` (String)
- `priority` (String) Priority class of the application
- `qos` (String) QoS class of the application
- `strategy` (Map of String) QoS Strategy of host application

<a id="nestedatt--spec--host_applications--cgroup_path"></a>
### Nested Schema for `spec.host_applications.cgroup_path`

Read-Only:

- `base` (String) cgroup base dir, the format is various across cgroup drivers
- `parent_dir` (String) cgroup parent path under base dir
- `relative_path` (String) cgroup relative path under parent dir



<a id="nestedatt--spec--resource_qos_strategy"></a>
### Nested Schema for `spec.resource_qos_strategy`

Read-Only:

- `be_class` (Attributes) ResourceQOS for BE pods. (see [below for nested schema](#nestedatt--spec--resource_qos_strategy--be_class))
- `cgroup_root` (Attributes) ResourceQOS for root cgroup. (see [below for nested schema](#nestedatt--spec--resource_qos_strategy--cgroup_root))
- `ls_class` (Attributes) ResourceQOS for LS pods. (see [below for nested schema](#nestedatt--spec--resource_qos_strategy--ls_class))
- `lsr_class` (Attributes) ResourceQOS for LSR pods. (see [below for nested schema](#nestedatt--spec--resource_qos_strategy--lsr_class))
- `system_class` (Attributes) ResourceQOS for system pods (see [below for nested schema](#nestedatt--spec--resource_qos_strategy--system_class))

<a id="nestedatt--spec--resource_qos_strategy--be_class"></a>
### Nested Schema for `spec.resource_qos_strategy.be_class`

Read-Only:

- `blkio_qos` (Attributes) (see [below for nested schema](#nestedatt--spec--resource_qos_strategy--be_class--blkio_qos))
- `cpu_qos` (Attributes) CPUQOSCfg stores node-level config of cpu qos (see [below for nested schema](#nestedatt--spec--resource_qos_strategy--be_class--cpu_qos))
- `memory_qos` (Attributes) MemoryQOSCfg stores node-level config of memory qos (see [below for nested schema](#nestedatt--spec--resource_qos_strategy--be_class--memory_qos))
- `resctrl_qos` (Attributes) ResctrlQOSCfg stores node-level config of resctrl qos (see [below for nested schema](#nestedatt--spec--resource_qos_strategy--be_class--resctrl_qos))

<a id="nestedatt--spec--resource_qos_strategy--be_class--blkio_qos"></a>
### Nested Schema for `spec.resource_qos_strategy.be_class.resctrl_qos`

Read-Only:

- `blocks` (Attributes List) (see [below for nested schema](#nestedatt--spec--resource_qos_strategy--be_class--resctrl_qos--blocks))
- `enable` (Boolean)

<a id="nestedatt--spec--resource_qos_strategy--be_class--resctrl_qos--blocks"></a>
### Nested Schema for `spec.resource_qos_strategy.be_class.resctrl_qos.blocks`

Read-Only:

- `io_cfg` (Attributes) (see [below for nested schema](#nestedatt--spec--resource_qos_strategy--be_class--resctrl_qos--blocks--io_cfg))
- `name` (String)
- `type` (String)

<a id="nestedatt--spec--resource_qos_strategy--be_class--resctrl_qos--blocks--io_cfg"></a>
### Nested Schema for `spec.resource_qos_strategy.be_class.resctrl_qos.blocks.type`

Read-Only:

- `io_weight_percent` (Number) This field is used to set the weight of a sub-group. Default value: 100. Valid values: 1 to 100.
- `read_bps` (Number) Throttling of throughput The value is set to 0, which indicates that the feature is disabled.
- `read_iops` (Number) Throttling of IOPS The value is set to 0, which indicates that the feature is disabled.
- `read_latency` (Number) Configure the weight-based throttling feature of blk-iocost Only used for RootClass After blk-iocost is enabled, the kernel calculates the proportion of requests that exceed the read or write latency threshold out of all requests. When the proportion is greater than the read or write latency percentile (95%), the kernel considers the disk to be saturated and reduces the rate at which requests are sent to the disk. the read latency threshold. Unit: microseconds.
- `write_bps` (Number)
- `write_iops` (Number)
- `write_latency` (Number) the write latency threshold. Unit: microseconds.




<a id="nestedatt--spec--resource_qos_strategy--be_class--cpu_qos"></a>
### Nested Schema for `spec.resource_qos_strategy.be_class.resctrl_qos`

Read-Only:

- `enable` (Boolean) Enable indicates whether the cpu qos is enabled.
- `group_identity` (Number) group identity value for pods, default = 0


<a id="nestedatt--spec--resource_qos_strategy--be_class--memory_qos"></a>
### Nested Schema for `spec.resource_qos_strategy.be_class.resctrl_qos`

Read-Only:

- `enable` (Boolean) Enable indicates whether the memory qos is enabled (default: false). This field is used for node-level control, while pod-level configuration is done with MemoryQOS and 'Policy' instead of an 'Enable' option. Please view the differences between MemoryQOSCfg and PodMemoryQOSConfig structs.
- `low_limit_percent` (Number) LowLimitPercent specifies the lowLimitFactor percentage to calculate 'memory.low', which TRIES BEST protecting memory from global reclamation when memory usage does not exceed the low limit unless no unprotected memcg can be reclaimed. NOTE: 'memory.low' should be larger than 'memory.min'. If spec.requests.memory == spec.limits.memory, pod 'memory.low' and 'memory.high' become invalid, while 'memory.wmark_ratio' is still in effect. Close: 0.
- `min_limit_percent` (Number) memcg qos If enabled, memcg qos will be set by the agent, where some fields are implicitly calculated from pod spec. 1. 'memory.min' := spec.requests.memory * minLimitFactor / 100 (use 0 if requests.memory is not set) 2. 'memory.low' := spec.requests.memory * lowLimitFactor / 100 (use 0 if requests.memory is not set) 3. 'memory.limit_in_bytes' := spec.limits.memory (set $node.allocatable.memory if limits.memory is not set) 4. 'memory.high' := floor[(spec.requests.memory + throttlingFactor / 100 * (memory.limit_in_bytes or node allocatable memory - spec.requests.memory))/pageSize] * pageSize MinLimitPercent specifies the minLimitFactor percentage to calculate 'memory.min', which protects memory from global reclamation when memory usage does not exceed the min limit. Close: 0.
- `oom_kill_group` (Number)
- `priority` (Number)
- `priority_enable` (Number) TODO: enhance the usages of oom priority and oom kill group
- `throttling_percent` (Number) ThrottlingPercent specifies the throttlingFactor percentage to calculate 'memory.high' with pod memory.limits or node allocatable memory, which triggers memcg direct reclamation when memory usage exceeds. Lower the factor brings more heavier reclaim pressure. Close: 0.
- `wmark_min_adj` (Number) wmark_min_adj (Anolis OS required) WmarkMinAdj specifies 'memory.wmark_min_adj' which adjusts per-memcg threshold for global memory reclamation. Lower the factor brings later reclamation. The adjustment uses different formula for different value range. [-25, 0)：global_wmark_min' = global_wmark_min + (global_wmark_min - 0) * wmarkMinAdj (0, 50]：global_wmark_min' = global_wmark_min + (global_wmark_low - global_wmark_min) * wmarkMinAdj Close: [LSR:0, LS:0, BE:0]. Recommended: [LSR:-25, LS:-25, BE:50].
- `wmark_ratio` (Number) wmark_ratio (Anolis OS required) Async memory reclamation is triggered when cgroup memory usage exceeds 'memory.wmark_high' and the reclamation stops when usage is below 'memory.wmark_low'. Basically, 'memory.wmark_high' := min(memory.high, memory.limit_in_bytes) * memory.memory.wmark_ratio 'memory.wmark_low' := min(memory.high, memory.limit_in_bytes) * (memory.wmark_ratio - memory.wmark_scale_factor) WmarkRatio specifies 'memory.wmark_ratio' that help calculate 'memory.wmark_high', which triggers async memory reclamation when memory usage exceeds. Close: 0. Recommended: 95.
- `wmark_scale_permill` (Number) WmarkScalePermill specifies 'memory.wmark_scale_factor' that helps calculate 'memory.wmark_low', which stops async memory reclamation when memory usage belows. Close: 50. Recommended: 20.


<a id="nestedatt--spec--resource_qos_strategy--be_class--resctrl_qos"></a>
### Nested Schema for `spec.resource_qos_strategy.be_class.resctrl_qos`

Read-Only:

- `cat_range_end_percent` (Number) LLC available range end for pods by percentage
- `cat_range_start_percent` (Number) LLC available range start for pods by percentage
- `enable` (Boolean) Enable indicates whether the resctrl qos is enabled.
- `mba_percent` (Number) MBA percent



<a id="nestedatt--spec--resource_qos_strategy--cgroup_root"></a>
### Nested Schema for `spec.resource_qos_strategy.cgroup_root`

Read-Only:

- `blkio_qos` (Attributes) (see [below for nested schema](#nestedatt--spec--resource_qos_strategy--cgroup_root--blkio_qos))
- `cpu_qos` (Attributes) CPUQOSCfg stores node-level config of cpu qos (see [below for nested schema](#nestedatt--spec--resource_qos_strategy--cgroup_root--cpu_qos))
- `memory_qos` (Attributes) MemoryQOSCfg stores node-level config of memory qos (see [below for nested schema](#nestedatt--spec--resource_qos_strategy--cgroup_root--memory_qos))
- `resctrl_qos` (Attributes) ResctrlQOSCfg stores node-level config of resctrl qos (see [below for nested schema](#nestedatt--spec--resource_qos_strategy--cgroup_root--resctrl_qos))

<a id="nestedatt--spec--resource_qos_strategy--cgroup_root--blkio_qos"></a>
### Nested Schema for `spec.resource_qos_strategy.cgroup_root.resctrl_qos`

Read-Only:

- `blocks` (Attributes List) (see [below for nested schema](#nestedatt--spec--resource_qos_strategy--cgroup_root--resctrl_qos--blocks))
- `enable` (Boolean)

<a id="nestedatt--spec--resource_qos_strategy--cgroup_root--resctrl_qos--blocks"></a>
### Nested Schema for `spec.resource_qos_strategy.cgroup_root.resctrl_qos.blocks`

Read-Only:

- `io_cfg` (Attributes) (see [below for nested schema](#nestedatt--spec--resource_qos_strategy--cgroup_root--resctrl_qos--blocks--io_cfg))
- `name` (String)
- `type` (String)

<a id="nestedatt--spec--resource_qos_strategy--cgroup_root--resctrl_qos--blocks--io_cfg"></a>
### Nested Schema for `spec.resource_qos_strategy.cgroup_root.resctrl_qos.blocks.type`

Read-Only:

- `io_weight_percent` (Number) This field is used to set the weight of a sub-group. Default value: 100. Valid values: 1 to 100.
- `read_bps` (Number) Throttling of throughput The value is set to 0, which indicates that the feature is disabled.
- `read_iops` (Number) Throttling of IOPS The value is set to 0, which indicates that the feature is disabled.
- `read_latency` (Number) Configure the weight-based throttling feature of blk-iocost Only used for RootClass After blk-iocost is enabled, the kernel calculates the proportion of requests that exceed the read or write latency threshold out of all requests. When the proportion is greater than the read or write latency percentile (95%), the kernel considers the disk to be saturated and reduces the rate at which requests are sent to the disk. the read latency threshold. Unit: microseconds.
- `write_bps` (Number)
- `write_iops` (Number)
- `write_latency` (Number) the write latency threshold. Unit: microseconds.




<a id="nestedatt--spec--resource_qos_strategy--cgroup_root--cpu_qos"></a>
### Nested Schema for `spec.resource_qos_strategy.cgroup_root.resctrl_qos`

Read-Only:

- `enable` (Boolean) Enable indicates whether the cpu qos is enabled.
- `group_identity` (Number) group identity value for pods, default = 0


<a id="nestedatt--spec--resource_qos_strategy--cgroup_root--memory_qos"></a>
### Nested Schema for `spec.resource_qos_strategy.cgroup_root.resctrl_qos`

Read-Only:

- `enable` (Boolean) Enable indicates whether the memory qos is enabled (default: false). This field is used for node-level control, while pod-level configuration is done with MemoryQOS and 'Policy' instead of an 'Enable' option. Please view the differences between MemoryQOSCfg and PodMemoryQOSConfig structs.
- `low_limit_percent` (Number) LowLimitPercent specifies the lowLimitFactor percentage to calculate 'memory.low', which TRIES BEST protecting memory from global reclamation when memory usage does not exceed the low limit unless no unprotected memcg can be reclaimed. NOTE: 'memory.low' should be larger than 'memory.min'. If spec.requests.memory == spec.limits.memory, pod 'memory.low' and 'memory.high' become invalid, while 'memory.wmark_ratio' is still in effect. Close: 0.
- `min_limit_percent` (Number) memcg qos If enabled, memcg qos will be set by the agent, where some fields are implicitly calculated from pod spec. 1. 'memory.min' := spec.requests.memory * minLimitFactor / 100 (use 0 if requests.memory is not set) 2. 'memory.low' := spec.requests.memory * lowLimitFactor / 100 (use 0 if requests.memory is not set) 3. 'memory.limit_in_bytes' := spec.limits.memory (set $node.allocatable.memory if limits.memory is not set) 4. 'memory.high' := floor[(spec.requests.memory + throttlingFactor / 100 * (memory.limit_in_bytes or node allocatable memory - spec.requests.memory))/pageSize] * pageSize MinLimitPercent specifies the minLimitFactor percentage to calculate 'memory.min', which protects memory from global reclamation when memory usage does not exceed the min limit. Close: 0.
- `oom_kill_group` (Number)
- `priority` (Number)
- `priority_enable` (Number) TODO: enhance the usages of oom priority and oom kill group
- `throttling_percent` (Number) ThrottlingPercent specifies the throttlingFactor percentage to calculate 'memory.high' with pod memory.limits or node allocatable memory, which triggers memcg direct reclamation when memory usage exceeds. Lower the factor brings more heavier reclaim pressure. Close: 0.
- `wmark_min_adj` (Number) wmark_min_adj (Anolis OS required) WmarkMinAdj specifies 'memory.wmark_min_adj' which adjusts per-memcg threshold for global memory reclamation. Lower the factor brings later reclamation. The adjustment uses different formula for different value range. [-25, 0)：global_wmark_min' = global_wmark_min + (global_wmark_min - 0) * wmarkMinAdj (0, 50]：global_wmark_min' = global_wmark_min + (global_wmark_low - global_wmark_min) * wmarkMinAdj Close: [LSR:0, LS:0, BE:0]. Recommended: [LSR:-25, LS:-25, BE:50].
- `wmark_ratio` (Number) wmark_ratio (Anolis OS required) Async memory reclamation is triggered when cgroup memory usage exceeds 'memory.wmark_high' and the reclamation stops when usage is below 'memory.wmark_low'. Basically, 'memory.wmark_high' := min(memory.high, memory.limit_in_bytes) * memory.memory.wmark_ratio 'memory.wmark_low' := min(memory.high, memory.limit_in_bytes) * (memory.wmark_ratio - memory.wmark_scale_factor) WmarkRatio specifies 'memory.wmark_ratio' that help calculate 'memory.wmark_high', which triggers async memory reclamation when memory usage exceeds. Close: 0. Recommended: 95.
- `wmark_scale_permill` (Number) WmarkScalePermill specifies 'memory.wmark_scale_factor' that helps calculate 'memory.wmark_low', which stops async memory reclamation when memory usage belows. Close: 50. Recommended: 20.


<a id="nestedatt--spec--resource_qos_strategy--cgroup_root--resctrl_qos"></a>
### Nested Schema for `spec.resource_qos_strategy.cgroup_root.resctrl_qos`

Read-Only:

- `cat_range_end_percent` (Number) LLC available range end for pods by percentage
- `cat_range_start_percent` (Number) LLC available range start for pods by percentage
- `enable` (Boolean) Enable indicates whether the resctrl qos is enabled.
- `mba_percent` (Number) MBA percent



<a id="nestedatt--spec--resource_qos_strategy--ls_class"></a>
### Nested Schema for `spec.resource_qos_strategy.ls_class`

Read-Only:

- `blkio_qos` (Attributes) (see [below for nested schema](#nestedatt--spec--resource_qos_strategy--ls_class--blkio_qos))
- `cpu_qos` (Attributes) CPUQOSCfg stores node-level config of cpu qos (see [below for nested schema](#nestedatt--spec--resource_qos_strategy--ls_class--cpu_qos))
- `memory_qos` (Attributes) MemoryQOSCfg stores node-level config of memory qos (see [below for nested schema](#nestedatt--spec--resource_qos_strategy--ls_class--memory_qos))
- `resctrl_qos` (Attributes) ResctrlQOSCfg stores node-level config of resctrl qos (see [below for nested schema](#nestedatt--spec--resource_qos_strategy--ls_class--resctrl_qos))

<a id="nestedatt--spec--resource_qos_strategy--ls_class--blkio_qos"></a>
### Nested Schema for `spec.resource_qos_strategy.ls_class.resctrl_qos`

Read-Only:

- `blocks` (Attributes List) (see [below for nested schema](#nestedatt--spec--resource_qos_strategy--ls_class--resctrl_qos--blocks))
- `enable` (Boolean)

<a id="nestedatt--spec--resource_qos_strategy--ls_class--resctrl_qos--blocks"></a>
### Nested Schema for `spec.resource_qos_strategy.ls_class.resctrl_qos.blocks`

Read-Only:

- `io_cfg` (Attributes) (see [below for nested schema](#nestedatt--spec--resource_qos_strategy--ls_class--resctrl_qos--blocks--io_cfg))
- `name` (String)
- `type` (String)

<a id="nestedatt--spec--resource_qos_strategy--ls_class--resctrl_qos--blocks--io_cfg"></a>
### Nested Schema for `spec.resource_qos_strategy.ls_class.resctrl_qos.blocks.type`

Read-Only:

- `io_weight_percent` (Number) This field is used to set the weight of a sub-group. Default value: 100. Valid values: 1 to 100.
- `read_bps` (Number) Throttling of throughput The value is set to 0, which indicates that the feature is disabled.
- `read_iops` (Number) Throttling of IOPS The value is set to 0, which indicates that the feature is disabled.
- `read_latency` (Number) Configure the weight-based throttling feature of blk-iocost Only used for RootClass After blk-iocost is enabled, the kernel calculates the proportion of requests that exceed the read or write latency threshold out of all requests. When the proportion is greater than the read or write latency percentile (95%), the kernel considers the disk to be saturated and reduces the rate at which requests are sent to the disk. the read latency threshold. Unit: microseconds.
- `write_bps` (Number)
- `write_iops` (Number)
- `write_latency` (Number) the write latency threshold. Unit: microseconds.




<a id="nestedatt--spec--resource_qos_strategy--ls_class--cpu_qos"></a>
### Nested Schema for `spec.resource_qos_strategy.ls_class.resctrl_qos`

Read-Only:

- `enable` (Boolean) Enable indicates whether the cpu qos is enabled.
- `group_identity` (Number) group identity value for pods, default = 0


<a id="nestedatt--spec--resource_qos_strategy--ls_class--memory_qos"></a>
### Nested Schema for `spec.resource_qos_strategy.ls_class.resctrl_qos`

Read-Only:

- `enable` (Boolean) Enable indicates whether the memory qos is enabled (default: false). This field is used for node-level control, while pod-level configuration is done with MemoryQOS and 'Policy' instead of an 'Enable' option. Please view the differences between MemoryQOSCfg and PodMemoryQOSConfig structs.
- `low_limit_percent` (Number) LowLimitPercent specifies the lowLimitFactor percentage to calculate 'memory.low', which TRIES BEST protecting memory from global reclamation when memory usage does not exceed the low limit unless no unprotected memcg can be reclaimed. NOTE: 'memory.low' should be larger than 'memory.min'. If spec.requests.memory == spec.limits.memory, pod 'memory.low' and 'memory.high' become invalid, while 'memory.wmark_ratio' is still in effect. Close: 0.
- `min_limit_percent` (Number) memcg qos If enabled, memcg qos will be set by the agent, where some fields are implicitly calculated from pod spec. 1. 'memory.min' := spec.requests.memory * minLimitFactor / 100 (use 0 if requests.memory is not set) 2. 'memory.low' := spec.requests.memory * lowLimitFactor / 100 (use 0 if requests.memory is not set) 3. 'memory.limit_in_bytes' := spec.limits.memory (set $node.allocatable.memory if limits.memory is not set) 4. 'memory.high' := floor[(spec.requests.memory + throttlingFactor / 100 * (memory.limit_in_bytes or node allocatable memory - spec.requests.memory))/pageSize] * pageSize MinLimitPercent specifies the minLimitFactor percentage to calculate 'memory.min', which protects memory from global reclamation when memory usage does not exceed the min limit. Close: 0.
- `oom_kill_group` (Number)
- `priority` (Number)
- `priority_enable` (Number) TODO: enhance the usages of oom priority and oom kill group
- `throttling_percent` (Number) ThrottlingPercent specifies the throttlingFactor percentage to calculate 'memory.high' with pod memory.limits or node allocatable memory, which triggers memcg direct reclamation when memory usage exceeds. Lower the factor brings more heavier reclaim pressure. Close: 0.
- `wmark_min_adj` (Number) wmark_min_adj (Anolis OS required) WmarkMinAdj specifies 'memory.wmark_min_adj' which adjusts per-memcg threshold for global memory reclamation. Lower the factor brings later reclamation. The adjustment uses different formula for different value range. [-25, 0)：global_wmark_min' = global_wmark_min + (global_wmark_min - 0) * wmarkMinAdj (0, 50]：global_wmark_min' = global_wmark_min + (global_wmark_low - global_wmark_min) * wmarkMinAdj Close: [LSR:0, LS:0, BE:0]. Recommended: [LSR:-25, LS:-25, BE:50].
- `wmark_ratio` (Number) wmark_ratio (Anolis OS required) Async memory reclamation is triggered when cgroup memory usage exceeds 'memory.wmark_high' and the reclamation stops when usage is below 'memory.wmark_low'. Basically, 'memory.wmark_high' := min(memory.high, memory.limit_in_bytes) * memory.memory.wmark_ratio 'memory.wmark_low' := min(memory.high, memory.limit_in_bytes) * (memory.wmark_ratio - memory.wmark_scale_factor) WmarkRatio specifies 'memory.wmark_ratio' that help calculate 'memory.wmark_high', which triggers async memory reclamation when memory usage exceeds. Close: 0. Recommended: 95.
- `wmark_scale_permill` (Number) WmarkScalePermill specifies 'memory.wmark_scale_factor' that helps calculate 'memory.wmark_low', which stops async memory reclamation when memory usage belows. Close: 50. Recommended: 20.


<a id="nestedatt--spec--resource_qos_strategy--ls_class--resctrl_qos"></a>
### Nested Schema for `spec.resource_qos_strategy.ls_class.resctrl_qos`

Read-Only:

- `cat_range_end_percent` (Number) LLC available range end for pods by percentage
- `cat_range_start_percent` (Number) LLC available range start for pods by percentage
- `enable` (Boolean) Enable indicates whether the resctrl qos is enabled.
- `mba_percent` (Number) MBA percent



<a id="nestedatt--spec--resource_qos_strategy--lsr_class"></a>
### Nested Schema for `spec.resource_qos_strategy.lsr_class`

Read-Only:

- `blkio_qos` (Attributes) (see [below for nested schema](#nestedatt--spec--resource_qos_strategy--lsr_class--blkio_qos))
- `cpu_qos` (Attributes) CPUQOSCfg stores node-level config of cpu qos (see [below for nested schema](#nestedatt--spec--resource_qos_strategy--lsr_class--cpu_qos))
- `memory_qos` (Attributes) MemoryQOSCfg stores node-level config of memory qos (see [below for nested schema](#nestedatt--spec--resource_qos_strategy--lsr_class--memory_qos))
- `resctrl_qos` (Attributes) ResctrlQOSCfg stores node-level config of resctrl qos (see [below for nested schema](#nestedatt--spec--resource_qos_strategy--lsr_class--resctrl_qos))

<a id="nestedatt--spec--resource_qos_strategy--lsr_class--blkio_qos"></a>
### Nested Schema for `spec.resource_qos_strategy.lsr_class.resctrl_qos`

Read-Only:

- `blocks` (Attributes List) (see [below for nested schema](#nestedatt--spec--resource_qos_strategy--lsr_class--resctrl_qos--blocks))
- `enable` (Boolean)

<a id="nestedatt--spec--resource_qos_strategy--lsr_class--resctrl_qos--blocks"></a>
### Nested Schema for `spec.resource_qos_strategy.lsr_class.resctrl_qos.blocks`

Read-Only:

- `io_cfg` (Attributes) (see [below for nested schema](#nestedatt--spec--resource_qos_strategy--lsr_class--resctrl_qos--blocks--io_cfg))
- `name` (String)
- `type` (String)

<a id="nestedatt--spec--resource_qos_strategy--lsr_class--resctrl_qos--blocks--io_cfg"></a>
### Nested Schema for `spec.resource_qos_strategy.lsr_class.resctrl_qos.blocks.type`

Read-Only:

- `io_weight_percent` (Number) This field is used to set the weight of a sub-group. Default value: 100. Valid values: 1 to 100.
- `read_bps` (Number) Throttling of throughput The value is set to 0, which indicates that the feature is disabled.
- `read_iops` (Number) Throttling of IOPS The value is set to 0, which indicates that the feature is disabled.
- `read_latency` (Number) Configure the weight-based throttling feature of blk-iocost Only used for RootClass After blk-iocost is enabled, the kernel calculates the proportion of requests that exceed the read or write latency threshold out of all requests. When the proportion is greater than the read or write latency percentile (95%), the kernel considers the disk to be saturated and reduces the rate at which requests are sent to the disk. the read latency threshold. Unit: microseconds.
- `write_bps` (Number)
- `write_iops` (Number)
- `write_latency` (Number) the write latency threshold. Unit: microseconds.




<a id="nestedatt--spec--resource_qos_strategy--lsr_class--cpu_qos"></a>
### Nested Schema for `spec.resource_qos_strategy.lsr_class.resctrl_qos`

Read-Only:

- `enable` (Boolean) Enable indicates whether the cpu qos is enabled.
- `group_identity` (Number) group identity value for pods, default = 0


<a id="nestedatt--spec--resource_qos_strategy--lsr_class--memory_qos"></a>
### Nested Schema for `spec.resource_qos_strategy.lsr_class.resctrl_qos`

Read-Only:

- `enable` (Boolean) Enable indicates whether the memory qos is enabled (default: false). This field is used for node-level control, while pod-level configuration is done with MemoryQOS and 'Policy' instead of an 'Enable' option. Please view the differences between MemoryQOSCfg and PodMemoryQOSConfig structs.
- `low_limit_percent` (Number) LowLimitPercent specifies the lowLimitFactor percentage to calculate 'memory.low', which TRIES BEST protecting memory from global reclamation when memory usage does not exceed the low limit unless no unprotected memcg can be reclaimed. NOTE: 'memory.low' should be larger than 'memory.min'. If spec.requests.memory == spec.limits.memory, pod 'memory.low' and 'memory.high' become invalid, while 'memory.wmark_ratio' is still in effect. Close: 0.
- `min_limit_percent` (Number) memcg qos If enabled, memcg qos will be set by the agent, where some fields are implicitly calculated from pod spec. 1. 'memory.min' := spec.requests.memory * minLimitFactor / 100 (use 0 if requests.memory is not set) 2. 'memory.low' := spec.requests.memory * lowLimitFactor / 100 (use 0 if requests.memory is not set) 3. 'memory.limit_in_bytes' := spec.limits.memory (set $node.allocatable.memory if limits.memory is not set) 4. 'memory.high' := floor[(spec.requests.memory + throttlingFactor / 100 * (memory.limit_in_bytes or node allocatable memory - spec.requests.memory))/pageSize] * pageSize MinLimitPercent specifies the minLimitFactor percentage to calculate 'memory.min', which protects memory from global reclamation when memory usage does not exceed the min limit. Close: 0.
- `oom_kill_group` (Number)
- `priority` (Number)
- `priority_enable` (Number) TODO: enhance the usages of oom priority and oom kill group
- `throttling_percent` (Number) ThrottlingPercent specifies the throttlingFactor percentage to calculate 'memory.high' with pod memory.limits or node allocatable memory, which triggers memcg direct reclamation when memory usage exceeds. Lower the factor brings more heavier reclaim pressure. Close: 0.
- `wmark_min_adj` (Number) wmark_min_adj (Anolis OS required) WmarkMinAdj specifies 'memory.wmark_min_adj' which adjusts per-memcg threshold for global memory reclamation. Lower the factor brings later reclamation. The adjustment uses different formula for different value range. [-25, 0)：global_wmark_min' = global_wmark_min + (global_wmark_min - 0) * wmarkMinAdj (0, 50]：global_wmark_min' = global_wmark_min + (global_wmark_low - global_wmark_min) * wmarkMinAdj Close: [LSR:0, LS:0, BE:0]. Recommended: [LSR:-25, LS:-25, BE:50].
- `wmark_ratio` (Number) wmark_ratio (Anolis OS required) Async memory reclamation is triggered when cgroup memory usage exceeds 'memory.wmark_high' and the reclamation stops when usage is below 'memory.wmark_low'. Basically, 'memory.wmark_high' := min(memory.high, memory.limit_in_bytes) * memory.memory.wmark_ratio 'memory.wmark_low' := min(memory.high, memory.limit_in_bytes) * (memory.wmark_ratio - memory.wmark_scale_factor) WmarkRatio specifies 'memory.wmark_ratio' that help calculate 'memory.wmark_high', which triggers async memory reclamation when memory usage exceeds. Close: 0. Recommended: 95.
- `wmark_scale_permill` (Number) WmarkScalePermill specifies 'memory.wmark_scale_factor' that helps calculate 'memory.wmark_low', which stops async memory reclamation when memory usage belows. Close: 50. Recommended: 20.


<a id="nestedatt--spec--resource_qos_strategy--lsr_class--resctrl_qos"></a>
### Nested Schema for `spec.resource_qos_strategy.lsr_class.resctrl_qos`

Read-Only:

- `cat_range_end_percent` (Number) LLC available range end for pods by percentage
- `cat_range_start_percent` (Number) LLC available range start for pods by percentage
- `enable` (Boolean) Enable indicates whether the resctrl qos is enabled.
- `mba_percent` (Number) MBA percent



<a id="nestedatt--spec--resource_qos_strategy--system_class"></a>
### Nested Schema for `spec.resource_qos_strategy.system_class`

Read-Only:

- `blkio_qos` (Attributes) (see [below for nested schema](#nestedatt--spec--resource_qos_strategy--system_class--blkio_qos))
- `cpu_qos` (Attributes) CPUQOSCfg stores node-level config of cpu qos (see [below for nested schema](#nestedatt--spec--resource_qos_strategy--system_class--cpu_qos))
- `memory_qos` (Attributes) MemoryQOSCfg stores node-level config of memory qos (see [below for nested schema](#nestedatt--spec--resource_qos_strategy--system_class--memory_qos))
- `resctrl_qos` (Attributes) ResctrlQOSCfg stores node-level config of resctrl qos (see [below for nested schema](#nestedatt--spec--resource_qos_strategy--system_class--resctrl_qos))

<a id="nestedatt--spec--resource_qos_strategy--system_class--blkio_qos"></a>
### Nested Schema for `spec.resource_qos_strategy.system_class.resctrl_qos`

Read-Only:

- `blocks` (Attributes List) (see [below for nested schema](#nestedatt--spec--resource_qos_strategy--system_class--resctrl_qos--blocks))
- `enable` (Boolean)

<a id="nestedatt--spec--resource_qos_strategy--system_class--resctrl_qos--blocks"></a>
### Nested Schema for `spec.resource_qos_strategy.system_class.resctrl_qos.blocks`

Read-Only:

- `io_cfg` (Attributes) (see [below for nested schema](#nestedatt--spec--resource_qos_strategy--system_class--resctrl_qos--blocks--io_cfg))
- `name` (String)
- `type` (String)

<a id="nestedatt--spec--resource_qos_strategy--system_class--resctrl_qos--blocks--io_cfg"></a>
### Nested Schema for `spec.resource_qos_strategy.system_class.resctrl_qos.blocks.type`

Read-Only:

- `io_weight_percent` (Number) This field is used to set the weight of a sub-group. Default value: 100. Valid values: 1 to 100.
- `read_bps` (Number) Throttling of throughput The value is set to 0, which indicates that the feature is disabled.
- `read_iops` (Number) Throttling of IOPS The value is set to 0, which indicates that the feature is disabled.
- `read_latency` (Number) Configure the weight-based throttling feature of blk-iocost Only used for RootClass After blk-iocost is enabled, the kernel calculates the proportion of requests that exceed the read or write latency threshold out of all requests. When the proportion is greater than the read or write latency percentile (95%), the kernel considers the disk to be saturated and reduces the rate at which requests are sent to the disk. the read latency threshold. Unit: microseconds.
- `write_bps` (Number)
- `write_iops` (Number)
- `write_latency` (Number) the write latency threshold. Unit: microseconds.




<a id="nestedatt--spec--resource_qos_strategy--system_class--cpu_qos"></a>
### Nested Schema for `spec.resource_qos_strategy.system_class.resctrl_qos`

Read-Only:

- `enable` (Boolean) Enable indicates whether the cpu qos is enabled.
- `group_identity` (Number) group identity value for pods, default = 0


<a id="nestedatt--spec--resource_qos_strategy--system_class--memory_qos"></a>
### Nested Schema for `spec.resource_qos_strategy.system_class.resctrl_qos`

Read-Only:

- `enable` (Boolean) Enable indicates whether the memory qos is enabled (default: false). This field is used for node-level control, while pod-level configuration is done with MemoryQOS and 'Policy' instead of an 'Enable' option. Please view the differences between MemoryQOSCfg and PodMemoryQOSConfig structs.
- `low_limit_percent` (Number) LowLimitPercent specifies the lowLimitFactor percentage to calculate 'memory.low', which TRIES BEST protecting memory from global reclamation when memory usage does not exceed the low limit unless no unprotected memcg can be reclaimed. NOTE: 'memory.low' should be larger than 'memory.min'. If spec.requests.memory == spec.limits.memory, pod 'memory.low' and 'memory.high' become invalid, while 'memory.wmark_ratio' is still in effect. Close: 0.
- `min_limit_percent` (Number) memcg qos If enabled, memcg qos will be set by the agent, where some fields are implicitly calculated from pod spec. 1. 'memory.min' := spec.requests.memory * minLimitFactor / 100 (use 0 if requests.memory is not set) 2. 'memory.low' := spec.requests.memory * lowLimitFactor / 100 (use 0 if requests.memory is not set) 3. 'memory.limit_in_bytes' := spec.limits.memory (set $node.allocatable.memory if limits.memory is not set) 4. 'memory.high' := floor[(spec.requests.memory + throttlingFactor / 100 * (memory.limit_in_bytes or node allocatable memory - spec.requests.memory))/pageSize] * pageSize MinLimitPercent specifies the minLimitFactor percentage to calculate 'memory.min', which protects memory from global reclamation when memory usage does not exceed the min limit. Close: 0.
- `oom_kill_group` (Number)
- `priority` (Number)
- `priority_enable` (Number) TODO: enhance the usages of oom priority and oom kill group
- `throttling_percent` (Number) ThrottlingPercent specifies the throttlingFactor percentage to calculate 'memory.high' with pod memory.limits or node allocatable memory, which triggers memcg direct reclamation when memory usage exceeds. Lower the factor brings more heavier reclaim pressure. Close: 0.
- `wmark_min_adj` (Number) wmark_min_adj (Anolis OS required) WmarkMinAdj specifies 'memory.wmark_min_adj' which adjusts per-memcg threshold for global memory reclamation. Lower the factor brings later reclamation. The adjustment uses different formula for different value range. [-25, 0)：global_wmark_min' = global_wmark_min + (global_wmark_min - 0) * wmarkMinAdj (0, 50]：global_wmark_min' = global_wmark_min + (global_wmark_low - global_wmark_min) * wmarkMinAdj Close: [LSR:0, LS:0, BE:0]. Recommended: [LSR:-25, LS:-25, BE:50].
- `wmark_ratio` (Number) wmark_ratio (Anolis OS required) Async memory reclamation is triggered when cgroup memory usage exceeds 'memory.wmark_high' and the reclamation stops when usage is below 'memory.wmark_low'. Basically, 'memory.wmark_high' := min(memory.high, memory.limit_in_bytes) * memory.memory.wmark_ratio 'memory.wmark_low' := min(memory.high, memory.limit_in_bytes) * (memory.wmark_ratio - memory.wmark_scale_factor) WmarkRatio specifies 'memory.wmark_ratio' that help calculate 'memory.wmark_high', which triggers async memory reclamation when memory usage exceeds. Close: 0. Recommended: 95.
- `wmark_scale_permill` (Number) WmarkScalePermill specifies 'memory.wmark_scale_factor' that helps calculate 'memory.wmark_low', which stops async memory reclamation when memory usage belows. Close: 50. Recommended: 20.


<a id="nestedatt--spec--resource_qos_strategy--system_class--resctrl_qos"></a>
### Nested Schema for `spec.resource_qos_strategy.system_class.resctrl_qos`

Read-Only:

- `cat_range_end_percent` (Number) LLC available range end for pods by percentage
- `cat_range_start_percent` (Number) LLC available range start for pods by percentage
- `enable` (Boolean) Enable indicates whether the resctrl qos is enabled.
- `mba_percent` (Number) MBA percent




<a id="nestedatt--spec--resource_used_threshold_with_be"></a>
### Nested Schema for `spec.resource_used_threshold_with_be`

Read-Only:

- `cpu_evict_be_satisfaction_lower_percent` (Number) be.satisfactionRate = be.CPURealLimit/be.CPURequest; be.cpuUsage = be.CPUUsed/be.CPURealLimit if be.satisfactionRate < CPUEvictBESatisfactionLowerPercent/100 && be.usage >= CPUEvictBEUsageThresholdPercent/100, then start to evict pod, and will evict to ${CPUEvictBESatisfactionUpperPercent}
- `cpu_evict_be_satisfaction_upper_percent` (Number) be.satisfactionRate = be.CPURealLimit/be.CPURequest if be.satisfactionRate > CPUEvictBESatisfactionUpperPercent/100, then stop to evict.
- `cpu_evict_be_usage_threshold_percent` (Number) if be.cpuUsage >= CPUEvictBEUsageThresholdPercent/100, then start to calculate the resources need to be released.
- `cpu_evict_time_window_seconds` (Number) when avg(cpuusage) > CPUEvictThresholdPercent, will start to evict pod by cpu, and avg(cpuusage) is calculated based on the most recent CPUEvictTimeWindowSeconds data
- `cpu_suppress_policy` (String) CPUSuppressPolicy
- `cpu_suppress_threshold_percent` (Number) cpu suppress threshold percentage (0,100), default = 65
- `enable` (Boolean) whether the strategy is enabled, default = false
- `memory_evict_lower_percent` (Number) lower: memory release util usage under MemoryEvictLowerPercent, default = MemoryEvictThresholdPercent - 2
- `memory_evict_threshold_percent` (Number) upper: memory evict threshold percentage (0,100), default = 70


<a id="nestedatt--spec--system_strategy"></a>
### Nested Schema for `spec.system_strategy`

Read-Only:

- `memcg_reap_back_ground` (Number) /sys/kernel/mm/memcg_reaper/reap_background
- `min_free_kbytes_factor` (Number) for /proc/sys/vm/min_free_kbytes, min_free_kbytes = minFreeKbytesFactor * nodeTotalMemory /10000
- `watermark_scale_factor` (Number) /proc/sys/vm/watermark_scale_factor
