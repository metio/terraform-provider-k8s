---
# generated by https://github.com/hashicorp/terraform-plugin-docs
page_title: "k8s_config_karmada_io_resource_interpreter_customization_v1alpha1 Data Source - terraform-provider-k8s"
subcategory: "config.karmada.io"
description: |-
  ResourceInterpreterCustomization describes the configuration of a specific resource for Karmada to get the structure. It has higher precedence than the default interpreter and the interpreter webhook.
---

# k8s_config_karmada_io_resource_interpreter_customization_v1alpha1 (Data Source)

ResourceInterpreterCustomization describes the configuration of a specific resource for Karmada to get the structure. It has higher precedence than the default interpreter and the interpreter webhook.

## Example Usage

```terraform
data "k8s_config_karmada_io_resource_interpreter_customization_v1alpha1" "example" {
  metadata = {
    name = "some-name"

  }
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `metadata` (Attributes) Data that helps uniquely identify this object. See https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata for more details. (see [below for nested schema](#nestedatt--metadata))

### Read-Only

- `api_version` (String) The API group of the requested resource.
- `id` (String) Contains the value `metadata.name`.
- `kind` (String) The type of the requested resource.
- `spec` (Attributes) Spec describes the configuration in detail. (see [below for nested schema](#nestedatt--spec))

<a id="nestedatt--metadata"></a>
### Nested Schema for `metadata`

Required:

- `name` (String) Unique identifier for this object. See https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names for more details.

Read-Only:

- `annotations` (Map of String) Keys and values that can be used by external tooling to store and retrieve arbitrary metadata about this object. See https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/ for more details.
- `labels` (Map of String) Keys and values that can be used to organize and categorize objects. See https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/ for more details.


<a id="nestedatt--spec"></a>
### Nested Schema for `spec`

Read-Only:

- `customizations` (Attributes) Customizations describe the interpretation rules. (see [below for nested schema](#nestedatt--spec--customizations))
- `target` (Attributes) CustomizationTarget represents the resource type that the customization applies to. (see [below for nested schema](#nestedatt--spec--target))

<a id="nestedatt--spec--customizations"></a>
### Nested Schema for `spec.customizations`

Read-Only:

- `dependency_interpretation` (Attributes) DependencyInterpretation describes the rules for Karmada to analyze the dependent resources. Karmada provides built-in rules for several standard Kubernetes types, see: https://karmada.io/docs/userguide/globalview/customizing-resource-interpreter/#interpretdependency If DependencyInterpretation is set, the built-in rules will be ignored. (see [below for nested schema](#nestedatt--spec--customizations--dependency_interpretation))
- `health_interpretation` (Attributes) HealthInterpretation describes the health assessment rules by which Karmada can assess the health state of the resource type. (see [below for nested schema](#nestedatt--spec--customizations--health_interpretation))
- `replica_resource` (Attributes) ReplicaResource describes the rules for Karmada to discover the resource's replica as well as resource requirements. It would be useful for those CRD resources that declare workload types like Deployment. It is usually not needed for Kubernetes native resources(Deployment, Job) as Karmada knows how to discover info from them. But if it is set, the built-in discovery rules will be ignored. (see [below for nested schema](#nestedatt--spec--customizations--replica_resource))
- `replica_revision` (Attributes) ReplicaRevision describes the rules for Karmada to revise the resource's replica. It would be useful for those CRD resources that declare workload types like Deployment. It is usually not needed for Kubernetes native resources(Deployment, Job) as Karmada knows how to revise replicas for them. But if it is set, the built-in revision rules will be ignored. (see [below for nested schema](#nestedatt--spec--customizations--replica_revision))
- `retention` (Attributes) Retention describes the desired behavior that Karmada should react on the changes made by member cluster components. This avoids system running into a meaningless loop that Karmada resource controller and the member cluster component continually applying opposite values of a field. For example, the 'replicas' of Deployment might be changed by the HPA controller on member cluster. In this case, Karmada should retain the 'replicas' and not try to change it. (see [below for nested schema](#nestedatt--spec--customizations--retention))
- `status_aggregation` (Attributes) StatusAggregation describes the rules for Karmada to aggregate status collected from member clusters to resource template. Karmada provides built-in rules for several standard Kubernetes types, see: https://karmada.io/docs/userguide/globalview/customizing-resource-interpreter/#aggregatestatus If StatusAggregation is set, the built-in rules will be ignored. (see [below for nested schema](#nestedatt--spec--customizations--status_aggregation))
- `status_reflection` (Attributes) StatusReflection describes the rules for Karmada to pick the resource's status. Karmada provides built-in rules for several standard Kubernetes types, see: https://karmada.io/docs/userguide/globalview/customizing-resource-interpreter/#interpretstatus If StatusReflection is set, the built-in rules will be ignored. (see [below for nested schema](#nestedatt--spec--customizations--status_reflection))

<a id="nestedatt--spec--customizations--dependency_interpretation"></a>
### Nested Schema for `spec.customizations.dependency_interpretation`

Read-Only:

- `lua_script` (String) LuaScript holds the Lua script that is used to interpret the dependencies of a specific resource. The script should implement a function as follows: luaScript: > function GetDependencies(desiredObj) dependencies = {} if desiredObj.spec.serviceAccountName ~= nil and desiredObj.spec.serviceAccountName ~= 'default' then dependency = {} dependency.apiVersion = 'v1' dependency.kind = 'ServiceAccount' dependency.name = desiredObj.spec.serviceAccountName dependency.namespace = desiredObj.namespace dependencies[1] = {} dependencies[1] = dependency end return dependencies end  The content of the LuaScript needs to be a whole function including both declaration and implementation.  The parameters will be supplied by the system: - desiredObj: the object represents the configuration to be applied to the member cluster.  The returned value should be expressed by a slice of DependentObjectReference.


<a id="nestedatt--spec--customizations--health_interpretation"></a>
### Nested Schema for `spec.customizations.health_interpretation`

Read-Only:

- `lua_script` (String) LuaScript holds the Lua script that is used to assess the health state of a specific resource. The script should implement a function as follows: luaScript: > function InterpretHealth(observedObj) if observedObj.status.readyReplicas == observedObj.spec.replicas then return true end end  The content of the LuaScript needs to be a whole function including both declaration and implementation.  The parameters will be supplied by the system: - observedObj: the object represents the configuration that is observed from a specific member cluster.  The returned boolean value indicates the health status.


<a id="nestedatt--spec--customizations--replica_resource"></a>
### Nested Schema for `spec.customizations.replica_resource`

Read-Only:

- `lua_script` (String) LuaScript holds the Lua script that is used to discover the resource's replica as well as resource requirements  The script should implement a function as follows: luaScript: > function GetReplicas(desiredObj) replica = desiredObj.spec.replicas requirement = {} requirement.nodeClaim = {} requirement.nodeClaim.nodeSelector = desiredObj.spec.template.spec.nodeSelector requirement.nodeClaim.tolerations = desiredObj.spec.template.spec.tolerations requirement.resourceRequest = desiredObj.spec.template.spec.containers[1].resources.limits return replica, requirement end  The content of the LuaScript needs to be a whole function including both declaration and implementation.  The parameters will be supplied by the system: - desiredObj: the object represents the configuration to be applied to the member cluster.  The function expects two return values: - replica: the declared replica number - requirement: the resource required by each replica expressed with a ResourceBindingSpec.ReplicaRequirements. The returned values will be set into a ResourceBinding or ClusterResourceBinding.


<a id="nestedatt--spec--customizations--replica_revision"></a>
### Nested Schema for `spec.customizations.replica_revision`

Read-Only:

- `lua_script` (String) LuaScript holds the Lua script that is used to revise replicas in the desired specification. The script should implement a function as follows: luaScript: > function ReviseReplica(desiredObj, desiredReplica) desiredObj.spec.replicas = desiredReplica return desiredObj end  The content of the LuaScript needs to be a whole function including both declaration and implementation.  The parameters will be supplied by the system: - desiredObj: the object represents the configuration to be applied to the member cluster. - desiredReplica: the replica number should be applied with.  The returned object should be a revised configuration which will be applied to member cluster eventually.


<a id="nestedatt--spec--customizations--retention"></a>
### Nested Schema for `spec.customizations.retention`

Read-Only:

- `lua_script` (String) LuaScript holds the Lua script that is used to retain runtime values to the desired specification.  The script should implement a function as follows: luaScript: > function Retain(desiredObj, observedObj) desiredObj.spec.fieldFoo = observedObj.spec.fieldFoo return desiredObj end  The content of the LuaScript needs to be a whole function including both declaration and implementation.  The parameters will be supplied by the system: - desiredObj: the object represents the configuration to be applied to the member cluster. - observedObj: the object represents the configuration that is observed from a specific member cluster.  The returned object should be a retained configuration which will be applied to member cluster eventually.


<a id="nestedatt--spec--customizations--status_aggregation"></a>
### Nested Schema for `spec.customizations.status_aggregation`

Read-Only:

- `lua_script` (String) LuaScript holds the Lua script that is used to aggregate decentralized statuses to the desired specification. The script should implement a function as follows: luaScript: > function AggregateStatus(desiredObj, statusItems) for i = 1, #statusItems do desiredObj.status.readyReplicas = desiredObj.status.readyReplicas + items[i].readyReplicas end return desiredObj end  The content of the LuaScript needs to be a whole function including both declaration and implementation.  The parameters will be supplied by the system: - desiredObj: the object represents a resource template. - statusItems: the slice of status expressed with AggregatedStatusItem.  The returned object should be a whole object with status aggregated.


<a id="nestedatt--spec--customizations--status_reflection"></a>
### Nested Schema for `spec.customizations.status_reflection`

Read-Only:

- `lua_script` (String) LuaScript holds the Lua script that is used to get the status from the observed specification. The script should implement a function as follows: luaScript: > function ReflectStatus(observedObj) status = {} status.readyReplicas = observedObj.status.observedObj return status end  The content of the LuaScript needs to be a whole function including both declaration and implementation.  The parameters will be supplied by the system: - observedObj: the object represents the configuration that is observed from a specific member cluster.  The returned status could be the whole status or part of it and will be set into both Work and ResourceBinding(ClusterResourceBinding).



<a id="nestedatt--spec--target"></a>
### Nested Schema for `spec.target`

Read-Only:

- `api_version` (String) APIVersion represents the API version of the target resource.
- `kind` (String) Kind represents the Kind of target resources.
